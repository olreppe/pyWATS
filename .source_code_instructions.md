# Source Code Type Safety - MANDATORY

**Context:** When writing ANY production code in `src/` directory

**Priority:** P0 - CRITICAL - Violations block deployment

**Applies To:** All code in `src/pywats/`, `src/pywats_client/`, `src/pywats_cfx/`, `src/pywats_events/`

---

## ðŸš¨ CRITICAL - This is THE Source of Truth

**Why P0 (Not P1):**
- Documentation learns from source code
- Tests mock source code behavior
- Examples demonstrate source code usage
- **If source is wrong, EVERYTHING downstream is wrong**

**Python's Dynamic Typing Risk:**
```python
# This "works" at runtime until it explodes:
def get_user(id):  # No types
    data = api_call(id)  # Returns dict? User? None? Exception?
    return data["name"]  # KeyError? AttributeError? Who knows!

# Customer hits error 3 months later in production
# Error: KeyError 'name' (data had 'username' instead)
```

**We cannot rely on compilation** - Python finds errors at runtime, often in production.

---

## ðŸš¨ MANDATORY RULES - ZERO EXCEPTIONS

### 1. All Functions MUST Have Type Hints

```python
# âŒ NEVER - No types
def get_report(id):
    return self._api.get(f"/reports/{id}")

# âŒ NEVER - Partial types
def get_report(id: str):
    return self._api.get(f"/reports/{id}")

# âœ… ALWAYS - Complete types
from typing import Optional
from pywats.models import Report

def get_report(self, id: str) -> Optional[Report]:
    """Get report by ID."""
    return self._api.get(f"/reports/{id}")
```

### 2. NO dict, Any, or object Returns

```python
# âŒ NEVER - dict return
def get_user(id: str) -> dict:
    return {"id": id, "name": "John"}

# âŒ NEVER - Any return
from typing import Any
def get_user(id: str) -> Any:
    return api.call()

# âŒ NEVER - object return
def get_user(id: str) -> object:
    return SomeClass()

# âœ… ALWAYS - Specific type
from pywats.models import User

def get_user(self, id: str) -> Optional[User]:
    """Get user by ID."""
    response = self._api.get(f"/users/{id}")
    if response.status_code == 404:
        return None
    return User(**response.json())
```

### 3. All Class Attributes MUST Be Typed

```python
# âŒ NEVER - Untyped attributes
class ReportService:
    def __init__(self):
        self.cache = {}  # Dict of what?
        self.api = None  # What type when set?

# âœ… ALWAYS - Typed attributes
from typing import Dict, Optional
from pywats.api import APIClient
from pywats.models import Report

class ReportService:
    cache: Dict[str, Report]
    api: APIClient
    
    def __init__(self, api: APIClient) -> None:
        self.cache = {}
        self.api = api
```

### 4. Use TypedDict or dataclass, NOT dict

```python
# âŒ NEVER - dict for structured data
def create_config() -> dict:
    return {
        "host": "localhost",
        "port": 8080,
        "timeout": 30
    }

# âœ… BETTER - TypedDict
from typing import TypedDict

class Config(TypedDict):
    host: str
    port: int
    timeout: int

def create_config() -> Config:
    return {
        "host": "localhost",
        "port": 8080,
        "timeout": 30
    }

# âœ… BEST - dataclass
from dataclasses import dataclass

@dataclass
class Config:
    host: str
    port: int
    timeout: int

def create_config() -> Config:
    return Config(
        host="localhost",
        port=8080,
        timeout=30
    )
```

### 5. Enums for All Known Values

```python
# âŒ NEVER - String literals
def filter_reports(status: str) -> List[Report]:
    if status not in ["passed", "failed", "error"]:
        raise ValueError(f"Invalid status: {status}")
    return self._query(status=status)

# âœ… ALWAYS - Enums
from enum import Enum
from typing import List
from pywats.models import Report

class ReportStatus(Enum):
    PASSED = "passed"
    FAILED = "failed"
    ERROR = "error"

def filter_reports(self, status: ReportStatus) -> List[Report]:
    """Filter reports by status."""
    return self._query(status=status.value)
```

### 6. Generics for Collections

```python
# âŒ NEVER - Untyped collections
def get_all_reports() -> list:
    return [...]

def get_cache() -> dict:
    return {}

# âœ… ALWAYS - Typed collections
from typing import List, Dict
from pywats.models import Report

def get_all_reports(self) -> List[Report]:
    """Get all reports."""
    return [...]

def get_cache(self) -> Dict[str, Report]:
    """Get report cache."""
    return {}
```

### 7. Optional for Nullable Values

```python
# âŒ NEVER - Implicit None
def find_user(email: str) -> User:
    """Find user by email."""
    user = db.query(email)
    return user  # Could be None!

# âœ… ALWAYS - Explicit Optional
from typing import Optional
from pywats.models import User

def find_user(self, email: str) -> Optional[User]:
    """
    Find user by email.
    
    Returns:
        User if found, None otherwise
    """
    return db.query(email)
```

---

## ðŸ” Validation Workflow - MANDATORY

### Before Every Commit

```bash
# 1. Type check with mypy (strict mode)
mypy src/pywats --strict

# 2. Check specific file
mypy src/pywats/domains/report/service.py --strict

# 3. No errors allowed
# Target: 0 errors for new code
# Legacy code: Track and reduce
```

### Mypy Configuration (pyproject.toml)

```toml
[tool.mypy]
python_version = "3.8"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_any_unimported = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
check_untyped_defs = true
strict_equality = true

# Gradually strict
[[tool.mypy.overrides]]
module = "pywats.domains.*"
disallow_untyped_defs = true
disallow_incomplete_defs = true

# Legacy code (temporary)
[[tool.mypy.overrides]]
module = "pywats.legacy.*"
ignore_errors = true
```

### IDE Integration

**VS Code (settings.json):**
```json
{
    "python.linting.mypyEnabled": true,
    "python.linting.mypyArgs": [
        "--strict",
        "--show-error-codes"
    ],
    "python.analysis.typeCheckingMode": "strict"
}
```

**PyCharm:**
- Settings â†’ Tools â†’ Python Integrated Tools
- Enable "Type Checking" with "mypy"
- Set to "Strict" mode

---

## ðŸ›¡ï¸ Automated Enforcement - Never Forget

### 1. Pre-Commit Hook (RECOMMENDED)

**Install:**
```bash
pip install pre-commit
```

**Create `.pre-commit-config.yaml`:**
```yaml
repos:
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.8.0
    hooks:
      - id: mypy
        args: [--strict, --show-error-codes]
        additional_dependencies: [types-all]
        files: ^src/
        exclude: ^src/pywats/legacy/

  - repo: local
    hooks:
      - id: type-safety-check
        name: Type Safety Validator
        entry: python scripts/validate_type_safety.py
        language: system
        files: ^src/.*\.py$
        pass_filenames: true
```

**Install hook:**
```bash
pre-commit install
```

**Now every commit runs mypy automatically!**

### 2. CI/CD Pipeline (MANDATORY)

**GitHub Actions (.github/workflows/type-check.yml):**
```yaml
name: Type Safety Check

on: [push, pull_request]

jobs:
  mypy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.8'
      - name: Install dependencies
        run: |
          pip install mypy types-all
          pip install -e .
      - name: Type check with mypy
        run: |
          mypy src/pywats --strict --show-error-codes
          
      - name: Fail if errors increased
        run: |
          python scripts/check_type_error_budget.py --max-errors 20
```

### 3. Custom Validation Script

**Create `scripts/validate_type_safety.py`:**
```python
#!/usr/bin/env python3
"""
Validate type safety in source files.
Blocks commits with type safety violations.
"""
import sys
import subprocess
from pathlib import Path
from typing import List

def check_file_types(file_path: Path) -> List[str]:
    """Check if file has proper type hints."""
    errors = []
    
    # Run mypy on single file
    result = subprocess.run(
        ["mypy", str(file_path), "--strict"],
        capture_output=True,
        text=True
    )
    
    if result.returncode != 0:
        errors.append(f"mypy errors in {file_path}:\n{result.stdout}")
    
    # Check for anti-patterns
    content = file_path.read_text()
    
    if "-> dict:" in content or "-> Dict:" in content:
        errors.append(f"{file_path}: FORBIDDEN dict return type found")
    
    if "-> Any:" in content:
        errors.append(f"{file_path}: FORBIDDEN Any return type found")
    
    if "def " in content and "->" not in content:
        # Simple check - could be improved
        errors.append(f"{file_path}: Function without return type hint found")
    
    return errors

def main(files: List[str]) -> int:
    """Validate type safety in provided files."""
    all_errors = []
    
    for file_str in files:
        file_path = Path(file_str)
        if file_path.suffix == ".py" and file_path.exists():
            errors = check_file_types(file_path)
            all_errors.extend(errors)
    
    if all_errors:
        print("âŒ TYPE SAFETY VIOLATIONS:")
        for error in all_errors:
            print(f"  {error}")
        print("\nâš ï¸  Commit blocked. Fix type safety issues above.")
        return 1
    
    print("âœ… Type safety validation passed")
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
```

**Make executable:**
```bash
chmod +x scripts/validate_type_safety.py
```

### 4. Type Error Budget (Track Progress)

**Create `scripts/check_type_error_budget.py`:**
```python
#!/usr/bin/env python3
"""
Track type error budget - prevent errors from increasing.
"""
import sys
import subprocess
from typing import Tuple

def count_mypy_errors() -> Tuple[int, str]:
    """Count current mypy errors."""
    result = subprocess.run(
        ["mypy", "src/pywats", "--strict"],
        capture_output=True,
        text=True
    )
    
    # Count error lines
    errors = [line for line in result.stdout.split("\n") if "error:" in line]
    return len(errors), result.stdout

def main(max_errors: int = 20) -> int:
    """
    Check if type errors are within budget.
    
    Args:
        max_errors: Maximum allowed errors (default: 20)
    """
    current_errors, output = count_mypy_errors()
    
    print(f"Current type errors: {current_errors}")
    print(f"Budget: {max_errors}")
    
    if current_errors > max_errors:
        print(f"\nâŒ FAILED: {current_errors} errors exceeds budget of {max_errors}")
        print("\nErrors:")
        print(output)
        return 1
    
    if current_errors > 0:
        print(f"\nâš ï¸  Warning: {current_errors} errors remaining (budget: {max_errors})")
        print("Goal: Reduce to 0")
    else:
        print("\nâœ… Perfect! Zero type errors!")
    
    return 0

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--max-errors", type=int, default=20)
    args = parser.parse_args()
    sys.exit(main(args.max_errors))
```

---

## ðŸ“Š Metrics & Goals

### Current State (Track This!)

```bash
# Count total type errors
mypy src/pywats --strict 2>&1 | grep "error:" | wc -l

# Count by severity
mypy src/pywats --strict 2>&1 | grep "error: Missing return" | wc -l
mypy src/pywats --strict 2>&1 | grep 'error: Function is missing a return type' | wc -l
mypy src/pywats --strict 2>&1 | grep 'error: Returning Any' | wc -l
```

### Goals

| Metric | Current | Target | Deadline |
|--------|---------|--------|----------|
| **Total mypy errors** | 16 | 0 | Q2 2026 |
| **New code errors** | 0 | 0 | Always |
| **dict returns** | ? | 0 | Q1 2026 |
| **Any returns** | ? | 0 | Q1 2026 |
| **Untyped functions** | ? | 0 | Q2 2026 |

### Weekly Dashboard

```bash
# Run this weekly, track in .workflow_knowledge.md
python scripts/type_safety_dashboard.py
```

**Output:**
```
Type Safety Dashboard
=====================
Total errors: 16 (â†“ from 18 last week)
New code: 0 errors âœ…
Legacy code: 16 errors (on track for Q2 goal)

By Category:
- Missing return types: 8
- Returning Any: 4  
- dict returns: 3
- Untyped parameters: 1

Progress: 98% (740 â†’ 16 errors since start)
```

---

## ðŸš« Common Anti-Patterns in Source Code

### Anti-Pattern 1: "We'll Add Types Later"

```python
# âŒ WRONG - Code ships without types
class ReportService:
    def __init__(self):
        self.cache = {}
    
    def get(self, id):
        return self.cache.get(id)
    
    # TODO: Add types later (never happens)
```

**Why it's bad:**
- "Later" never comes
- Other code copies this pattern
- Tests mock untyped behavior
- Docs show untyped examples
- Drift accelerates

**Fix:** Write types FIRST, not later.

### Anti-Pattern 2: "Partial Typing"

```python
# âŒ WRONG - Half typed
def process_report(report: Report):  # â† Has type
    data = extract_data(report)  # â† No type
    result = transform(data)     # â† No type
    return result                # â† No type
```

**Why it's bad:**
- Type safety breaks at first untyped function
- Mypy can't help you
- False sense of security

**Fix:** Type EVERYTHING in the chain.

### Anti-Pattern 3: "Type: ignore Comments"

```python
# âŒ WRONG - Silencing errors
def get_user(id: str) -> User:
    return api.call(id)  # type: ignore  # â† Hiding real error
```

**Why it's bad:**
- Hides real bugs
- Accumulates over time
- Defeats purpose of type checking

**Fix:** Fix the actual error, don't silence it.

### Anti-Pattern 4: "Dict is Fine"

```python
# âŒ WRONG - dict for structured data
def get_config() -> dict:
    return {
        "timeout": 30,
        "retries": 3,
        "host": "localhost"
    }

# Later...
config = get_config()
port = config["port"]  # KeyError - port doesn't exist!
```

**Why it's bad:**
- No autocomplete
- No type checking
- Runtime KeyError
- Refactoring nightmare

**Fix:** Use TypedDict or dataclass.

---

## âœ… Enforcement Checklist

### For Developers

**Before committing code:**
- [ ] All functions have return type hints
- [ ] All parameters have type hints
- [ ] No `dict`, `Any`, or `object` returns
- [ ] Enums used for known values
- [ ] Collections are typed (List[X], Dict[K,V])
- [ ] Optional used for nullable returns
- [ ] Ran `mypy <file> --strict` - 0 errors
- [ ] Pre-commit hook passed

### For Reviewers

**PR review checklist:**
- [ ] No new type: ignore comments
- [ ] No dict/Any returns introduced
- [ ] All new functions typed
- [ ] mypy --strict passes on changed files
- [ ] Type error budget not exceeded
- [ ] Enums used instead of string literals

### For CI/CD

**Automated checks:**
- [ ] mypy --strict runs on all PRs
- [ ] Type error budget enforced
- [ ] No dict/Any returns detected
- [ ] Pre-commit hooks required

---

## ðŸŽ¯ Migration Strategy (For Legacy Code)

### Don't Fix Everything at Once

```python
# Legacy file with no types
# Option 1: Add to ignore list temporarily
# Option 2: Add basic types gradually
# Option 3: Rewrite with types (if critical)

# Recommended: Gradual typing
# 1. Add return types first
# 2. Add parameter types second
# 3. Fix Any/dict returns third
# 4. Remove from ignore list
```

### Type Error Budget Approach

```yaml
# Week 1: Establish baseline
Baseline: 740 errors

# Week 2-4: No new errors (enforce)
Target: 740 errors (hold the line)

# Month 2: Reduce by 10% per week
Targets: 666, 600, 540, 486 errors

# Month 3: Reduce by 20% per week
Targets: 389, 311, 249, 199 errors

# Month 4: Final push
Targets: 100, 50, 20, 0 errors
```

---

## ðŸ“š Resources

### Learning Type Hints

- [PEP 484 â€“ Type Hints](https://peps.python.org/pep-0484/)
- [mypy documentation](https://mypy.readthedocs.io/)
- [typing module docs](https://docs.python.org/3/library/typing.html)

### Tools

- **mypy** - Static type checker
- **pyright** - Microsoft's type checker (faster)
- **pyre** - Facebook's type checker
- **pytype** - Google's type checker

### IDE Support

- VS Code: Pylance extension
- PyCharm: Built-in type checking
- Vim: ALE with mypy

---

**Remember:** Source code type safety is **non-negotiable**. This is the foundation everything else builds on. Automate enforcement so you never forget.

**Last Updated:** February 3, 2026  
**Enforcement:** P0 - MANDATORY - Pre-commit hooks + CI/CD required
