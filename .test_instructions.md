# Testing Code Standards - MANDATORY

**Context:** When writing ANY test code in `tests/` directory

**Priority:** P0 - Type safety violations are critical errors

---

## ðŸš¨ CRITICAL RULES - NO EXCEPTIONS

### 1. Type-Safe Test Fixtures

```python
# âŒ NEVER - Untyped fixtures
@pytest.fixture
def sample_report():
    return {"id": "123", "status": "passed"}

# âŒ NEVER - Mock returns Any
@pytest.fixture
def mock_api():
    return Mock()

# âœ… ALWAYS - Typed fixtures
from pywats.models import Report, ReportStatus

@pytest.fixture
def sample_report() -> Report:
    return Report(
        id="123",
        status=ReportStatus.PASSED,
        serial_number="SN123",
        # ... all required fields
    )

# âœ… ALWAYS - Typed mocks with spec
from unittest.mock import MagicMock
from pywats import WATS

@pytest.fixture
def mock_api() -> MagicMock:
    mock = MagicMock(spec=WATS)
    mock.report.get.return_value = sample_report()
    return mock
```

### 2. Type-Safe Test Functions

```python
# âŒ NEVER - Untyped test parameters
def test_get_report(mock_api):
    result = mock_api.report.get("123")
    assert result["status"] == "passed"

# âœ… ALWAYS - Typed parameters and assertions
from pywats import WATS
from pywats.models import Report, ReportStatus
from unittest.mock import MagicMock

def test_get_report(mock_api: MagicMock) -> None:
    result: Report = mock_api.report.get("123")
    assert result.status == ReportStatus.PASSED
```

### 3. No dict/Any Returns in Tests

```python
# âŒ NEVER - Creating test data as dicts
def test_process_report():
    report_data = {"id": "123", "status": "passed"}
    result = process(report_data)

# âŒ NEVER - Any type in test helpers
def create_test_report() -> Any:
    return {"id": "123"}

# âœ… ALWAYS - Use actual models
from pywats.models import Report, ReportStatus

def test_process_report() -> None:
    report: Report = Report(
        id="123",
        status=ReportStatus.PASSED,
        serial_number="SN123"
    )
    result = process(report)

# âœ… ALWAYS - Typed test helpers
def create_test_report() -> Report:
    return Report(
        id="123",
        status=ReportStatus.PASSED,
        serial_number="SN123"
    )
```

### 4. Mock Patches - Type-Safe

```python
# âŒ NEVER - Untyped patches
@patch('module.function')
def test_something(mock_func):
    mock_func.return_value = {"data": "value"}

# âœ… ALWAYS - Typed patches with spec
from unittest.mock import MagicMock, patch
from pywats.models import Report

@patch('module.function')
def test_something(mock_func: MagicMock) -> None:
    result = Report(id="123", status=ReportStatus.PASSED)
    mock_func.return_value = result
```

---

## ðŸ“‹ Test Organization Standards

### 1. File Structure

```plaintext
tests/
â”œâ”€â”€ conftest.py              # Shared fixtures
â”œâ”€â”€ domains/
â”‚   â”œâ”€â”€ report/
â”‚   â”‚   â”œâ”€â”€ test_service.py  # Service tests
â”‚   â”‚   â”œâ”€â”€ test_models.py   # Model tests
â”‚   â”‚   â””â”€â”€ conftest.py      # Domain fixtures
â”‚   â””â”€â”€ process/
â”‚       â””â”€â”€ ...
â”œâ”€â”€ client/
â”‚   â”œâ”€â”€ test_logging.py
â”‚   â””â”€â”€ test_conversion_log.py
â””â”€â”€ cross_cutting/
    â””â”€â”€ test_logging.py
```

### 2. Test Naming

```python
# âœ… DESCRIPTIVE - What, When, Expected
def test_get_report_with_valid_id_returns_report() -> None:
    ...

def test_get_report_with_invalid_id_raises_not_found() -> None:
    ...

def test_query_reports_with_status_filter_returns_matching_reports() -> None:
    ...

# âŒ VAGUE - Don't do this
def test_get_report() -> None:
    ...

def test_report_error() -> None:
    ...
```

### 3. Test Structure (Arrange-Act-Assert)

```python
def test_get_report_with_valid_id_returns_report(
    mock_api: MagicMock,
    sample_report: Report
) -> None:
    # Arrange
    report_id: str = "123"
    mock_api.report.get.return_value = sample_report
    
    # Act
    result: Report = mock_api.report.get(report_id)
    
    # Assert
    assert result.id == report_id
    assert result.status == ReportStatus.PASSED
    mock_api.report.get.assert_called_once_with(report_id)
```

---

## ðŸŽ¯ Fixture Standards

### 1. Shared Fixtures (conftest.py)

```python
# tests/conftest.py
from typing import Generator
import pytest
from pywats import WATS
from pywats.models import Report, ReportStatus

@pytest.fixture
def wats_client() -> Generator[WATS, None, None]:
    """Provide configured WATS client."""
    client = WATS(base_url="https://test-server")
    yield client
    # Cleanup if needed

@pytest.fixture
def sample_report() -> Report:
    """Provide sample passed report."""
    return Report(
        id="R123",
        serial_number="SN123",
        status=ReportStatus.PASSED,
        process_name="FCT",
        station_name="Station_1"
    )
```

### 2. Domain Fixtures (domain conftest.py)

```python
# tests/domains/report/conftest.py
from typing import List
import pytest
from pywats.models import Report, ReportStatus

@pytest.fixture
def multiple_reports() -> List[Report]:
    """Provide list of reports for testing."""
    return [
        Report(id=f"R{i}", status=ReportStatus.PASSED, serial_number=f"SN{i}")
        for i in range(1, 4)
    ]
```

### 3. Parametrized Fixtures

```python
@pytest.fixture(params=[
    ReportStatus.PASSED,
    ReportStatus.FAILED,
    ReportStatus.ERROR
])
def report_status(request: pytest.FixtureRequest) -> ReportStatus:
    """Provide different report statuses."""
    return request.param

def test_query_by_status(report_status: ReportStatus) -> None:
    # Test runs 3 times with different statuses
    ...
```

---

## ðŸ” Validation Requirements

### Pre-Commit Checklist

- [ ] All test functions have return type annotation (â†’ None)
- [ ] All test parameters are typed
- [ ] All fixtures have return type annotations
- [ ] No `dict` or `Any` in test data
- [ ] Enums used for known values
- [ ] Mocks use `spec` parameter
- [ ] Test names are descriptive
- [ ] Arrange-Act-Assert structure clear

### Type Checking

```bash
# Tests must pass type checking
mypy tests/ --strict

# Target: 0 errors in test code
```

### Coverage

```bash
# Run with coverage
pytest --cov=src/pywats --cov-report=term-missing

# Target: 95%+ coverage
```

---

## ðŸš« Common Anti-Patterns

### Anti-Pattern 1: Magic Values

```python
# âŒ WRONG - Magic strings/numbers
def test_something():
    result = get_report("123")
    assert result.status == "passed"

# âœ… CORRECT - Named constants or enums
def test_something() -> None:
    TEST_REPORT_ID: str = "123"
    result: Report = get_report(TEST_REPORT_ID)
    assert result.status == ReportStatus.PASSED
```

### Anti-Pattern 2: Overly Complex Tests

```python
# âŒ WRONG - Testing multiple things
def test_report_operations():
    report = create_report()
    assert report.id
    assert report.status == "passed"
    updated = update_report(report)
    assert updated.status == "failed"
    # Too much in one test!

# âœ… CORRECT - One test, one concept
def test_create_report_assigns_id() -> None:
    report: Report = create_report()
    assert report.id is not None

def test_update_report_changes_status() -> None:
    original: Report = create_report(status=ReportStatus.PASSED)
    updated: Report = update_report(original, ReportStatus.FAILED)
    assert updated.status == ReportStatus.FAILED
```

### Anti-Pattern 3: Tight Coupling

```python
# âŒ WRONG - Testing implementation details
def test_report_service_uses_cache():
    service._cache.get.assert_called()  # Don't test internals

# âœ… CORRECT - Test behavior
def test_report_service_returns_cached_report() -> None:
    report1: Report = service.get("123")
    report2: Report = service.get("123")
    assert report1 is report2  # Test observable behavior
```

---

## âœ… Mocking Best Practices

### 1. Use spec Parameter

```python
from unittest.mock import MagicMock
from pywats import WATS

# âœ… ALWAYS - Mock with spec
mock_api: MagicMock = MagicMock(spec=WATS)

# This will fail at runtime if method doesn't exist
mock_api.report.nonexistent_method()  # AttributeError
```

### 2. Type Mock Return Values

```python
from unittest.mock import MagicMock
from pywats.models import Report, ReportStatus

mock_api: MagicMock = MagicMock(spec=WATS)

# âœ… Type the return value
expected_report = Report(
    id="123",
    status=ReportStatus.PASSED,
    serial_number="SN123"
)
mock_api.report.get.return_value = expected_report

# Now you have typed result
result: Report = mock_api.report.get("123")
```

### 3. Patch at Usage Location

```python
# âŒ WRONG - Patch where defined
@patch('pywats.core.cache.Cache.get')
def test_something(mock_get): ...

# âœ… CORRECT - Patch where used
@patch('pywats.domains.report.service.Cache.get')
def test_something(mock_get: MagicMock) -> None: ...
```

---

## ðŸ“Š Test Coverage Standards

### Coverage Targets

- **Domain Services:** 95%+ coverage
- **Models:** 90%+ coverage
- **Utilities:** 95%+ coverage
- **Client Code:** 85%+ coverage

### What to Test

âœ… **Always Test:**
- Public API methods
- Error handling
- Edge cases
- Type conversions
- Enum usage
- Optional parameters

âŒ **Don't Test:**
- Private methods (test via public API)
- Third-party library internals
- Generated code (e.g., dataclass methods)

---

## ðŸŽ¯ Async Testing

### Type-Safe Async Tests

```python
import pytest
from typing import List
from pywats.models import Report
from pywats_client.domains.report.async_service import AsyncReportService

@pytest.mark.asyncio
async def test_async_get_report() -> None:
    service = AsyncReportService(base_url="https://test")
    
    result: Report = await service.get("123")
    
    assert result.id == "123"

@pytest.mark.asyncio
async def test_async_query_reports() -> None:
    service = AsyncReportService(base_url="https://test")
    
    results: List[Report] = await service.query_reports(
        status=ReportStatus.PASSED
    )
    
    assert len(results) > 0
    assert all(r.status == ReportStatus.PASSED for r in results)
```

---

## ðŸ“ Documentation in Tests

### Docstrings for Complex Tests

```python
def test_complex_query_with_multiple_filters() -> None:
    """
    Test querying reports with multiple filters.
    
    Verifies that:
    1. Status filter works correctly
    2. Serial number filter works correctly
    3. Combined filters return intersection of results
    4. Results are properly typed as Report objects
    """
    # Test implementation...
```

---

## ðŸ”§ Test Utilities

### Create Type-Safe Test Helpers

```python
# tests/utils/factories.py
from pywats.models import Report, ReportStatus
from typing import Optional

def create_test_report(
    id: str = "R123",
    status: ReportStatus = ReportStatus.PASSED,
    serial_number: Optional[str] = None
) -> Report:
    """
    Create a test report with sensible defaults.
    
    Args:
        id: Report ID
        status: Report status
        serial_number: Serial number (defaults to "SN_{id}")
    
    Returns:
        Configured Report instance
    """
    return Report(
        id=id,
        status=status,
        serial_number=serial_number or f"SN_{id}",
        process_name="FCT",
        station_name="Station_1"
    )
```

---

## âœ… Validation Checklist

Before committing tests:

- [ ] All tests pass: `pytest`
- [ ] Type checking passes: `mypy tests/ --strict`
- [ ] No warnings: `pytest -W error`
- [ ] Coverage target met: `pytest --cov`
- [ ] Test names are descriptive
- [ ] All fixtures typed
- [ ] No `dict`/`Any` in test data
- [ ] Mocks use `spec`
- [ ] Enums used for known values

---

**Last Updated:** February 3, 2026  
**Applies To:** All test code in `tests/`  
**Enforcement:** Mandatory - violations block PR merge
