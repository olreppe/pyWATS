## pyWATS REST API Code Generation Strategy

### ✅ Objective
Design and document a scalable, prompt-ready structure for generating the internal REST API layer (`pyWATS.rest_api`) based on a local `.json` Swagger (OpenAPI) specification.

This REST API layer will:
- Be **generated on-demand** into **actual code files**, not at runtime.
- Serve as a foundation for higher-level `pyWATS.*` modules.
- Reflect **logical endpoint categories** in its structure.
- Be scalable to large API specs (many models, endpoints).
- Support both **public** and **internal** versions of the REST API (as defined in `openapi_public.json` and `openapi_internal.json`)

### ✅ Authentication & Connection
The WATS REST API uses **Basic Authentication** with the following structure:
- **Authentication Method**: HTTP Basic Authentication
- **Token Format**: Base64 encoded credentials in the format `username:password`
- **Header**: `Authorization: Basic {token}`

#### Connection Configuration
The pyWATS library uses a centralized connection configuration through the `pyWATS.connection` module:
- **Base URL**: Configurable WATS server URL (not the OpenAPI spec server)
- **Token**: Basic authentication token (Base64 encoded)
- **Timeout**: Request timeout in seconds (default: 30)
- **Referrer**: Referrer header for internal API access

Example connection setup:
```python
from pyWATS.connection import create_connection

# Create connection with custom base URL
connection = create_connection(
    base_url="https://your-wats-server.com",
    token="your_base64_encoded_token"
)

# Test connection
if connection.test_connection():
    print("Connection successful!")
```

#### Environment Variables Support
The connection module supports configuration via environment variables:
- `WATS_BASE_URL`: Base URL for the WATS API
- `WATS_AUTH_TOKEN`: Authentication token (Base64 encoded)
- `WATS_TIMEOUT`: Request timeout in seconds (optional)
- `WATS_REFERRER`: Referrer header (optional)

### ✅ API Versioning
- Two Swagger/OpenAPI specs are used:
  - `openapi_public.json` → contains endpoints exposed to API consumers
  - `openapi_internal.json` → contains extended internal endpoints
- Initially, **both will be used** to generate modules.
- Over time, internal-only endpoints will be deprecated or hidden to reduce exposure.
- The codebase should allow **easily removing internal API use** later without major refactors.

### ⚠️ Internal API Security Note
When using internal endpoints, additional requirements may apply:
- A **referrer header** or authenticated origin may be required by the server.
- This must be handled in `rest_api.client.py` to ensure requests to internal endpoints are accepted.
- The connection module automatically sets appropriate referrer headers based on the base URL.

### ✅ Code Generation Principles
- Source: Swagger/OpenAPI **`.json` file** (downloaded locally)
- Tool: `openapi-python-client` or similar
- Output should be static Python code checked into the repository
- No runtime codegen or reflection
- Generated code may be committed or excluded via `.gitignore` depending on policy

### ✅ Folder Structure (Implemented)
```plaintext
pyWATS/
├── __init__.py
├── connection.py                  # Connection management and authentication
└── rest_api/
    ├── __init__.py
    ├── client.py                  # REST client session, auth, config
    ├── models/                    # Generated Pydantic models (split per category)
    │   ├── __init__.py
    │   ├── common.py              # Common/shared models
    │   ├── asset.py               # Asset-related models
    │   ├── product.py             # Product-related models
    │   ├── production.py          # Production-related models
    │   └── report.py              # Report-related models
    ├── endpoints/                 # Category-based API modules
    │   ├── __init__.py
    │   ├── app.py                 # Application endpoints
    │   ├── asset.py               # Asset management endpoints
    │   ├── auth.py                # Authentication endpoints
    │   ├── internal.py            # Internal endpoints
    │   ├── product.py             # Product endpoints
    │   ├── production.py          # Production endpoints
    │   └── report.py              # Report endpoints
    └── exceptions.py              # HTTP / model errors
```

### ✅ Usage Philosophy
The structure supports both direct imports and modular access:
```python
# Direct endpoint imports
from pyWATS.rest_api.endpoints.asset import get_assets, get_asset_by_id
from pyWATS.rest_api.endpoints.production import get_production_data

# Connection-based usage
from pyWATS.connection import create_connection
connection = create_connection(
    base_url="https://your-server.com",
    token="your_token"
)

# All endpoints use the default client configured by connection
assets = get_assets(odata_top=10)
```

### ✅ Authentication Flow
1. Create connection using `pyWATS.connection.create_connection()`
2. Connection automatically configures the default REST client
3. All endpoint functions use the configured client
4. Basic authentication header is automatically included in all requests
5. Referrer headers are set for internal API compatibility

### ✅ Error Handling
The API provides comprehensive error handling through custom exceptions:
- `AuthenticationError`: For 401 authentication failures
- `AuthorizationError`: For 403 permission issues
- `NotFoundError`: For 404 resource not found
- `ValidationError`: For 400 validation failures
- `RateLimitError`: For 429 rate limiting
- `ServerError`: For 5xx server errors
- `NetworkError`: For network connectivity issues

### ✅ Prompt Guidance for Copilot
When writing prompts or documentation for Copilot, focus on:
- Logical grouping of endpoints by category ("tags" in OpenAPI)
- Function naming based on action + noun: `get_report`, `delete_unit`, etc.
- Consistent parameter naming (`report_id`, `serial_number`)
- Ensure models are placed with or near the endpoint that uses them
- Keep each model file focused and small — avoid one giant `models.py`
- Always configure connection before using endpoints
- Use appropriate error handling for different failure scenarios

### ✅ Naming Convention
- Endpoint groups reflect OpenAPI tags (e.g., "App", "Asset", "Mes")
- These become folders or modules: `rest_api.app`, `rest_api.asset`, etc.
- Models follow the same grouping
- Function names follow REST verb + resource logic

### ✅ Benefits of On-Disk Generation
- Easier debugging
- Static analysis & IDE support
- Easy for Copilot to index
- Works with version control
- Clear separation of concerns with connection management

### 🔜 Next Actions
- Use uploaded OpenAPI JSON to:
  - Parse tags and endpoints
  - Generate structural stub files
  - Group endpoints by logical tags like `App`, `Asset`, etc.
- Scaffold:
  - `rest_api/app/*.py` for endpoints like `get_uut_report`, `post_dynamic_yield`
  - `rest_api/models/app/*.py` for schemas used in `App` endpoints
  - `rest_api/client.py` with base URL and session logic, including referrer support if needed

### ✅ Example Usage
See `main.py` for complete examples of:
- Connection setup with authentication
- Asset management operations
- Error handling patterns
- OData query usage

> Confirmed OpenAPI JSON files are valid. Structural code generation can proceed once explicitly requested.
> Authentication and connection management have been implemented and documented.